BX.namespace("Aspro"),BX.Aspro.Utils={isFunction:e=>"function"==typeof e||"function"==typeof window[e],readyDOM:e=>{"loading"!==document.readyState?e():document.addEventListener("DOMContentLoaded",e)}},BX.namespace("Aspro.Loader"),BX.namespace("Aspro.Observer"),(()=>{const e=[],t=[],r=[];BX.Aspro.Loader=new class{constructor(){}addCss(...t){return new Promise(((r,s)=>{(t=t.filter((t=>BX.type.isString(t)&&!~e.indexOf(t)))).length?BX.loadCSS(t,(()=>{t.forEach((t=>{e.push(t)})),r()})):r()}))}addJs(...e){return new Promise(((r,s)=>{(e=e.filter((e=>BX.type.isString(e)&&!~t.indexOf(e)))).length?BX.loadScript(e,(()=>{e.forEach((e=>{t.push(e)})),r()})):r()}))}addExt(...e){return new Promise(((t,s)=>{(e=(e=e.map((e=>`aspro_${e}`))).filter((e=>BX.type.isString(e)&&!~r.indexOf(e)))).length?BX.loadExt(e).then((()=>{e.forEach((e=>{r.push(e)})),t()})):t()}))}added(s){return BX.type.isString(s)&&s?!!~e.indexOf(s)||!!~t.indexOf(s)||!!~r.indexOf(`aspro_${s}`):{ext:r,css:e,js:t}}add(e){let t=(e=BX.type.isObject(e)?e:{}).ext?BX.type.isArray(e.ext)?e.ext:[e.ext]:[],r=e.css?BX.type.isArray(e.css)?e.css:[e.css]:[],s=e.js?BX.type.isArray(e.js)?e.js:[e.js]:[];return new Promise(((e,n)=>{this.addExt(...t).then((()=>{this.addCss(...r).then((()=>{this.addJs(...s).then((()=>{e()}))}))}))}))}once(e){return(e=BX.type.isObject(e)?e:{}).appear=BX.type.isString(e.appear)?[e.appear]:BX.type.isArray(e.appear)?e.appear:null,e.add=BX.type.isObject(e.add)?e.add:null,new Promise(((t,r)=>{e.appear?BX.Aspro.Observer.appear(...e.appear).then((()=>{e.add?this.add(e.add).then(t):t()})):e.add?this.add(e.add).then(t):t()}))}};const s={root:null,rootMargin:"0px",threshold:0};BX.Aspro.Observer=new class{constructor(){this.mkIntersectionConfig()}mkIntersectionConfig(e){BX.type.isObject(e)?(s.root=e.root,s.rootMargin=e.rootMargin,s.threshold=e.threshold):s.rootMargin="0px"}appear(e,t){return t=BX.type.isObject(t)&&t?t:s,new Promise(((r,s)=>{if(BX.type.isString(e)){let s=document.querySelectorAll(e);if(s.length){let e=new IntersectionObserver(((e,t)=>{e.forEach((e=>{e.isIntersecting&&(t.unobserve(e.target),r())}))}),t);s.forEach((t=>{e.observe(t)}))}else r()}else BX.type.isDomNode(e)?new IntersectionObserver(((e,t)=>{e.forEach((e=>{e.isIntersecting&&(t.unobserve(e.target),r())}))}),t).observe(e):r()}))}}})();